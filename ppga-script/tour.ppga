/*
    A multi-line comment
*/
// static methods still require a colon (getting rid of this would require a type system).
// This table is provided by the bot runtime, we're making a fake one here to make 
// this script runnable with vanilla Lua.
global util = {"get_args"=fn(){},"error"=fn(_,e){print(e);}};

let args = util:get_args(@);

let a =  -1;
let b = 2 + 2;
let c = 3 * 3;
let d = 4 / 4;
let e = 4 \ 4;  // integer division
let f = 5 ** 5;
let g = 6 % 7;
let h = "abc" .. "d"; // Concatenation is .. (using + would require a type system)
let i = true != false and 3 < 4 or 5 >= 6 or 3 <= 7 and 10 > 2;

{
    // A block.
    let arr = [1, 2, 3];
    let dict = {1 = 2, 3 = 4};
    let empty = {};
}

fn f(x) {
    print("x", "is", x);
    // string interpolation, transpiles to "x is " .. tostring(x)
    print(f"x is {x}");

    // Create a new local variable
    let y = x;

    // Create a new global variable
    global z = 5;

    let arr = [1, 2, 3];
    if input() { 
        // returns the array arr as an object
        // the result is an array: [x, arr]
        return x, arr;  // => return (x), (arr)
    }

    // unpacks the array arr as a sequence of its elements
    // the result is an array: [x, 1, 2, 3]
    return x, ...arr;  // => return x, arr
}


// Create a global function
global fn h() { }


// Create and call a closure
// Not sure about the opt thing. I don't like lua ignoring arguments 
// so this could a way to provide an optional parameter.
let g = fn (y, f?) {
    if f {
        print(f(y));
    } else {
        print(y);
    }
};
g(12); // 12
g(12, fn(x) => x * x); // 144


for i in range(1, 10) {
    let fib = [0, 1];
    // Code inside `lua` blocks is de-indented once 
    // and then directly pasted into the resulting lua file.
    lua {
        for j = 2, i do
            fib[j] = fib[j - 2] + fib[j - 1]
        end
    }
    print(fib[len(fib) - 1]);
}

let container = [1, 2, 3];
container["string"] = "hello";

// Table iteration, uses pairs
for key, value in container { 
    print(key, value);
}

// Array iteration, uses ipairs
fori idx, value in container {
    print(idx, value);
}

// All API methods work Go-style: they return a tuple of (ok, err),
// where either of the elements, but not both, is nil.
fn may_fail() { 
    return nil, "error";
}

fn main() {
    // The ? operator simplifies Go-style error hanlding.
    let ok = may_fail()?;
    // The line above will expand into the following code:
    //
    // let ok = nil
    // { 
    //     let _ok_L94S2015, _err_L94S2015 = ...may_fail();
    //     if _err_L94S2015 != nil { 
    //          util:error(_err_L94S2015);
    //          return (_err_L94S2015);
    //     }
    //     ok = _ok_L94S2015;
    // }
    return ok;
}

let res = main();
print(f"Main returned: {res}");
